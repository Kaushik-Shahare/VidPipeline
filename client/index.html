<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VidPipeline</title>
    <style>
      :root {
        --bg: #0f0f0f;
        --panel: #181818;
        --text: #e6e6e6;
        --muted: #aaaaaa;
        --accent: #ff3d00;
        --card: #202020;
        --border: #2a2a2a;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      a {
        color: inherit;
        text-decoration: none;
      }

      /* Header */
      .header {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 10px 16px;
        background: var(--panel);
        border-bottom: 1px solid var(--border);
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .logo {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 700;
        letter-spacing: 0.3px;
      }
      .logo-badge {
        width: 28px;
        height: 28px;
        background: var(--accent);
        border-radius: 6px;
        display: inline-block;
      }
      .search {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .search input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 20px;
        border: 1px solid var(--border);
        background: #111;
        color: var(--text);
      }
      .actions {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .btn {
        padding: 10px 14px;
        background: var(--accent);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
      }

      /* Layout */
      .layout {
        display: grid;
        grid-template-columns: 220px 1fr;
      }
      .sidebar {
        background: var(--panel);
        border-right: 1px solid var(--border);
        min-height: calc(100vh - 56px);
        padding: 12px;
        position: sticky;
        top: 56px;
      }
      .nav-item {
        padding: 10px 12px;
        border-radius: 8px;
        color: var(--muted);
        cursor: pointer;
      }
      .nav-item:hover {
        background: var(--card);
        color: var(--text);
      }

      /* Main */
      .main {
        padding: 18px;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
        gap: 16px;
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .thumb {
        width: 100%;
        aspect-ratio: 16/9;
        background: #0a0a0a;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 14px;
      }
      .card-body {
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .title {
        font-size: 15px;
        font-weight: 600;
        line-height: 1.3;
      }
      .meta {
        font-size: 12px;
        color: var(--muted);
      }

      /* Upload modal */
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .modal {
        width: 520px;
        max-width: 92vw;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
      }
      .modal-header {
        padding: 12px 14px;
        border-bottom: 1px solid var(--border);
        font-weight: 700;
      }
      .modal-body {
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .progress {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      progress {
        width: 100%;
        height: 10px;
      }
      .close-x {
        background: transparent;
        color: var(--text);
        border: none;
        font-size: 16px;
        cursor: pointer;
      }

      @media (max-width: 900px) {
        .layout {
          grid-template-columns: 1fr;
        }
        .sidebar {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <header class="header">
      <div class="logo">
        <span class="logo-badge"></span>
        <span>VidPipeline</span>
      </div>
      <div class="search">
        <input id="searchInput" type="search" placeholder="Search videos..." />
      </div>
      <div class="actions">
        <button class="btn" id="openUpload">Upload</button>
      </div>
    </header>

    <div class="layout">
      <aside class="sidebar">
        <div class="nav-item">Home</div>
        <div class="nav-item">Library</div>
        <div class="nav-item">Uploads</div>
      </aside>
      <main class="main">
        <div id="videoGrid" class="grid"></div>
      </main>
    </div>

    <!-- Upload Modal -->
    <div id="uploadModal" class="modal-backdrop">
      <div class="modal">
        <div class="modal-header">Upload a Video</div>
        <div class="modal-body">
          <input type="file" id="videoFile" accept="video/*" />
          <div class="progress">
            <progress id="progressBar" value="0" max="100"></progress>
            <span id="progressText"></span>
          </div>
          <div id="result"></div>
          <div style="display: flex; gap: 8px; justify-content: flex-end">
            <button class="btn" id="startUpload">Start Upload</button>
            <button class="close-x" id="closeUpload">Close</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const BACKEND_URL = "http://localhost:8000"; // FastAPI backend

      function isAbsoluteUrl(u) {
        return typeof u === "string" && /^(https?:)?\/\//i.test(u);
      }

      function resolveUrl(u) {
        if (!u) return null;
        return isAbsoluteUrl(u) ? u : `${BACKEND_URL}${u}`;
      }

      const grid = document.getElementById("videoGrid");
      const searchInput = document.getElementById("searchInput");
      let allVideos = [];

      function renderGrid(list) {
        grid.innerHTML = "";
        if (!list.length) {
          grid.innerHTML =
            '<div style="color:var(--muted)">No videos yet.</div>';
          return;
        }
        list.forEach((v) => {
          const card = document.createElement("div");
          card.className = "card";
          const thumb = document.createElement("img");
          thumb.className = "thumb";
          thumb.src = v.thumbnail_url ? resolveUrl(v.thumbnail_url) : null;
          thumb.alt = "No thumbnail";
          const body = document.createElement("div");
          body.className = "card-body";
          const title = document.createElement("div");
          title.className = "title";
          title.textContent = v.title || "Untitled";
          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent =
            v.status === "completed"
              ? "Ready to watch"
              : v.status || "processing";
          const link = document.createElement("a");
          link.className = "btn";
          link.style.width = "fit-content";
          link.href = `./streaming.html?v=${encodeURIComponent(v.video_hash)}`;
          link.textContent = "Watch";
          body.appendChild(title);
          body.appendChild(meta);
          body.appendChild(link);
          card.appendChild(thumb);
          card.appendChild(body);
          grid.appendChild(card);
        });
      }

      async function fetchVideos() {
        const resp = await fetch(`${BACKEND_URL}/videos`);
        const videos = await resp.json();
        allVideos = videos;
        renderGrid(videos);
      }

      searchInput.addEventListener("input", () => {
        const q = searchInput.value.toLowerCase().trim();
        const filtered = allVideos.filter((v) =>
          (v.title || "").toLowerCase().includes(q),
        );
        renderGrid(filtered);
      });

      // Upload modal controls
      const modal = document.getElementById("uploadModal");
      document
        .getElementById("openUpload")
        .addEventListener("click", () => (modal.style.display = "flex"));
      document
        .getElementById("closeUpload")
        .addEventListener("click", () => (modal.style.display = "none"));
      document
        .getElementById("startUpload")
        .addEventListener("click", uploadVideo);

      async function uploadVideo() {
        const fileInput = document.getElementById("videoFile");
        const file = fileInput.files && fileInput.files[0];
        if (!file) {
          alert("Select a file first");
          return;
        }

        // Validate file type by content, not extension
        const validVideoTypes = [
          "video/mp4", "video/quicktime", "video/x-msvideo",
          "video/x-matroska", "video/webm", "video/mpeg"
        ];
        if (!validVideoTypes.includes(file.type)) {
          alert(`Invalid file type: ${file.type}. Please upload a video file.`);
          return;
        }

        const CHUNK_SIZE = 2 * 1024 * 1024; // 2MB per chunk
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        const videoTitle = file.name;

        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        const resultDiv = document.getElementById("result");

        try {
          // Initialize upload with file metadata
          const initResp = await fetch(`${BACKEND_URL}/videos/init`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              title: videoTitle,
              total_chunks: totalChunks,
              file_size: file.size,
              mime_type: file.type
            }),
          });

          if (!initResp.ok) {
            const error = await initResp.json();
            throw new Error(error.detail || "Failed to initialize upload");
          }

          const initData = await initResp.json();
          const videoHash = initData.video_hash;

          // Determine which chunks to upload (support resumable uploads)
          let chunksToUpload = [];
          let uploadedCount = 0;
          
          if (initData.resumable && initData.uploaded_chunks && initData.uploaded_chunks.length > 0) {
            // Resume upload - only upload missing chunks
            chunksToUpload = initData.missing_chunks || [];
            uploadedCount = initData.uploaded_chunks.length;
            progressText.innerText = `Resuming upload - ${uploadedCount}/${totalChunks} chunks already uploaded`;
            progressBar.value = Math.round((uploadedCount / totalChunks) * 100);
            console.log(`Resuming: ${uploadedCount} chunks already uploaded, ${chunksToUpload.length} remaining`);
          } else {
            // Fresh upload - upload all chunks
            chunksToUpload = Array.from({ length: totalChunks }, (_, i) => i);
            console.log(`Starting fresh upload of ${totalChunks} chunks`);
          }

          // Upload chunks with retry logic
          const MAX_RETRIES = 3;
          const failedChunks = [];

          for (const i of chunksToUpload) {
            const start = i * CHUNK_SIZE;
            const end = Math.min(file.size, start + CHUNK_SIZE);
            const chunk = file.slice(start, end);

            let uploadSuccess = false;
            let lastError = null;

            // Retry logic for individual chunk
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
              try {
                // Create FormData to send chunk to backend
                const formData = new FormData();
                formData.append('chunk', chunk);

                // Upload chunk to backend
                const uploadResp = await fetch(
                  `${BACKEND_URL}/videos/upload_chunk/${videoHash}/${i}`,
                  {
                    method: "POST",
                    body: formData,
                  }
                );

                if (!uploadResp.ok) {
                  const errorData = await uploadResp.json();
                  throw new Error(errorData.detail || 'Upload failed');
                }

                const uploadData = await uploadResp.json();
                console.log(`Chunk ${i} uploaded successfully (attempt ${attempt + 1}/${MAX_RETRIES})`);
                uploadSuccess = true;
                break; // Success, exit retry loop

              } catch (error) {
                lastError = error;
                console.warn(`Chunk ${i} upload attempt ${attempt + 1}/${MAX_RETRIES} failed:`, error.message);
                
                if (attempt < MAX_RETRIES - 1) {
                  // Exponential backoff: 1s, 2s, 4s
                  const delay = Math.pow(2, attempt) * 1000;
                  console.log(`Retrying chunk ${i} in ${delay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                }
              }
            }

            if (!uploadSuccess) {
              // All retries failed for this chunk
              failedChunks.push(i);
              console.error(`Chunk ${i} failed after ${MAX_RETRIES} attempts:`, lastError.message);
              // Continue with other chunks instead of stopping
            } else {
              uploadedCount++;
            }

            // Update progress
            const percent = Math.round((uploadedCount / totalChunks) * 100);
            progressBar.value = percent;
            progressText.innerText = `Uploaded ${uploadedCount}/${totalChunks} (${percent}%)`;
          }

          // Check if any chunks failed
          if (failedChunks.length > 0) {
            throw new Error(
              `Failed to upload ${failedChunks.length} chunk(s): ${failedChunks.slice(0, 5).join(', ')}${failedChunks.length > 5 ? '...' : ''}. ` +
              `You can retry this upload to resume from where it failed.`
            );
          }

          // Finalize upload
          const finalizeResp = await fetch(
            `${BACKEND_URL}/videos/finalize/${videoHash}`,
            { method: "POST" },
          );

          if (!finalizeResp.ok) {
            const finalizeError = await finalizeResp.json();
            throw new Error(finalizeError.detail || "Failed to finalize upload");
          }

          const finalizeData = await finalizeResp.json();
          resultDiv.innerHTML = `<strong>Processing started:</strong> <a href="./streaming.html?v=${encodeURIComponent(videoHash)}">Go to Watch Page</a>`;
          progressText.innerText = "Upload completed!";
          progressBar.value = 100;

          // refresh list after a short delay to allow processing
          setTimeout(fetchVideos, 2000);
        } catch (error) {
          resultDiv.innerHTML = `<strong style="color: var(--accent);">Error:</strong> ${error.message}`;
          console.error("Upload error:", error);
        }
      }

      fetchVideos();
    </script>
  </body>
</html>
